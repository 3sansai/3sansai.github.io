<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring IOC</title>
      <link href="2020/12/17/Spring%20IOC/"/>
      <url>2020/12/17/Spring%20IOC/</url>
      
        <content type="html"><![CDATA[<h3 id="IOC介绍"><a href="#IOC介绍" class="headerlink" title="IOC介绍"></a>IOC介绍</h3><p>控制反转，是面向对象编程的一种设计原则，可以用来降低计算机代码耦合度。其中最常见的放是叫做依赖注入（简称DI），还有一种放是教“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中</p><h3 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h3><h4 id="什么是IOC（控制反转）"><a href="#什么是IOC（控制反转）" class="headerlink" title="什么是IOC（控制反转）"></a>什么是IOC（控制反转）</h4><ol><li>把对象创建和对象之间的调用过程，交给Spring管理</li><li>使用IOC目的，为了降低耦合度</li></ol><h4 id="IOC底层原理"><a href="#IOC底层原理" class="headerlink" title="IOC底层原理"></a>IOC底层原理</h4><p>xml解析、工厂模式、反射<br><img src="//blog.3sansai.fun/2020/12/17/Spring IOC/../../../../img/spring/spring05.png" alt="1-0-1"></p><h3 id="IOC接口"><a href="#IOC接口" class="headerlink" title="IOC接口"></a>IOC接口</h3><ol><li>BeanFactory：IOC容器基本实现，是Spring内部使用接口，不提供开发人员进行示用</li></ol><ul><li>加载配置文件时不会创建对象，在获取对象（使用）才去创建对象</li></ul><ol start="2"><li>ApplicationContenxt：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用</li></ol><ul><li>加载配置文件时候就会把在配置文件对象进行创建</li></ul><h3 id="什么是Bean管理"><a href="#什么是Bean管理" class="headerlink" title="什么是Bean管理"></a>什么是Bean管理</h3><h5 id="Bean管理指的是两个操作"><a href="#Bean管理指的是两个操作" class="headerlink" title="Bean管理指的是两个操作"></a>Bean管理指的是两个操作</h5><ol><li>Spring创建对象</li><li>Spring注入属性</li></ol>]]></content>
      
      
      <categories>
          
          <category> Forever Love </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 框架 </tag>
            
            <tag> Forever Love </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="2020/12/16/Spring/"/>
      <url>2020/12/16/Spring/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Spring框架概述"><a href="#Spring框架概述" class="headerlink" title="Spring框架概述"></a>Spring框架概述</h3><ol><li>Spring是轻量级的开源的JavaEE框架</li><li>Spring可以解决企业应用开发的复杂性</li><li>Spring有两个核心部分：IOC和Aop<br>（1）IOC：控制反转，把创建对象的过程交给Spring进行管理<br>（2）Aop：面向切面，不修改源代码进行功能增强</li><li>Spring特点<br>（1）方便解耦，简化开发<br>（2）Aop编程支持<br>（3）方便测试程序<br>（4）方便和其他框架进行整合<br>（5）降低JavaAPI的使用难度<br>（6）方便进行事务操作</li></ol><h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><ol><li>下载Spring5（官网spring.io）</li><li>下载地址：<a href="https://repo.spring.io/release/org/springframework/spring/" target="_blank" rel="noopener">https://repo.spring.io/release/org/springframework/spring/</a></li><li>示用ideal创建普通Java项目导入Spring jar包<br><img src="//blog.3sansai.fun/2020/12/16/Spring/../../../../img/spring/spring02.png" alt="1-0-1"></li></ol><p>基本功能包<br><img src="//blog.3sansai.fun/2020/12/16/Spring/../../../../img/spring/spring03.png" alt="1-0-2"><br>还需日志包避免报错<br><img src="//blog.3sansai.fun/2020/12/16/Spring/../../../../img/spring/spring04.png" alt="1-0-3"></p><ol start="4"><li><p>创建普通类，在类里创建普通的方法</p></li><li><p>创建Spring配置文件，在配置文件中配置创建对象<br>（1）Spring配置文件使用xml文件格式<br><img src="//blog.3sansai.fun/2020/12/16/Spring/../../../../img/spring/spring01.png" alt="2-0-1"></p></li><li><p>创建测试类测试</p></li></ol><h3 id="Spring参考资料链接"><a href="#Spring参考资料链接" class="headerlink" title="Spring参考资料链接"></a>Spring参考资料链接</h3><ol><li><a href="https://blog.csdn.net/weixin_45496190/article/details/107059038" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45496190/article/details/107059038</a></li><li><a href="https://blog.csdn.net/weixin_45496190/article/details/107067200" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45496190/article/details/107067200</a></li><li><a href="https://blog.csdn.net/weixin_45496190/article/details/107071204" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45496190/article/details/107071204</a></li><li><a href="https://blog.csdn.net/weixin_45496190/article/details/107082732" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45496190/article/details/107082732</a></li><li><a href="https://blog.csdn.net/weixin_45496190/article/details/107092107" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45496190/article/details/107092107</a></li></ol><h3 id="Spring-Boot参考资料链接"><a href="#Spring-Boot参考资料链接" class="headerlink" title="Spring Boot参考资料链接"></a>Spring Boot参考资料链接</h3><ol><li><a href="https://blog.csdn.net/weixin_45496190/article/details/107296832" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45496190/article/details/107296832</a></li><li><a href="https://blog.csdn.net/weixin_45496190/article/details/107288240" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45496190/article/details/107288240</a></li><li><a href="https://blog.csdn.net/weixin_45496190/article/details/107168783" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45496190/article/details/107168783</a></li><li><a href="https://blog.csdn.net/weixin_45496190/article/details/107140300" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45496190/article/details/107140300</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Forever Love </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 框架 </tag>
            
            <tag> Forever Love </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>猫儿武士幽雾</title>
      <link href="2020/02/14/%E7%8C%AB%E5%84%BF%E6%AD%A6%E5%A3%AB%E5%B9%BD%E9%9B%BE/"/>
      <url>2020/02/14/%E7%8C%AB%E5%84%BF%E6%AD%A6%E5%A3%AB%E5%B9%BD%E9%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>等待</p><h2 id="运输"><a href="#运输" class="headerlink" title="运输"></a>运输</h2><p>未知</p>]]></content>
      
      
      <categories>
          
          <category> JK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 45 </tag>
            
            <tag> M </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泷岛海&amp;小岚中&amp;鲸落&amp;狗皮皮</title>
      <link href="2020/02/12/%E6%B3%B7%E5%B2%9B%E6%B5%B7&amp;%E5%B0%8F%E5%B2%9A%E4%B8%AD&amp;%E9%B2%B8%E8%90%BD&amp;%E7%8B%97%E7%9A%AE%E7%9A%AE/"/>
      <url>2020/02/12/%E6%B3%B7%E5%B2%9B%E6%B5%B7&amp;%E5%B0%8F%E5%B2%9A%E4%B8%AD&amp;%E9%B2%B8%E8%90%BD&amp;%E7%8B%97%E7%9A%AE%E7%9A%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>等待</p><h2 id="运输"><a href="#运输" class="headerlink" title="运输"></a>运输</h2><p>未知</p>]]></content>
      
      
      <categories>
          
          <category> JK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 45 </tag>
            
            <tag> M </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>樱花家族小粉</title>
      <link href="2020/02/02/%E6%A8%B1%E8%8A%B1%E5%AE%B6%E6%97%8F%E5%B0%8F%E7%B2%89/"/>
      <url>2020/02/02/%E6%A8%B1%E8%8A%B1%E5%AE%B6%E6%97%8F%E5%B0%8F%E7%B2%89/</url>
      
        <content type="html"><![CDATA[<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>等待</p><h2 id="运输"><a href="#运输" class="headerlink" title="运输"></a>运输</h2><p>未知</p>]]></content>
      
      
      <categories>
          
          <category> JK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 45 </tag>
            
            <tag> M </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>樱花家族小蓝</title>
      <link href="2020/02/01/%E6%A8%B1%E8%8A%B1%E5%AE%B6%E6%97%8F%E5%B0%8F%E8%93%9D/"/>
      <url>2020/02/01/%E6%A8%B1%E8%8A%B1%E5%AE%B6%E6%97%8F%E5%B0%8F%E8%93%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>等待</p><h2 id="运输"><a href="#运输" class="headerlink" title="运输"></a>运输</h2><p>未知</p>]]></content>
      
      
      <categories>
          
          <category> JK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 45 </tag>
            
            <tag> M </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>茶羽中</title>
      <link href="2020/02/01/%E6%96%B0%E5%B9%B4%E6%9C%9F%E9%97%B4/"/>
      <url>2020/02/01/%E6%96%B0%E5%B9%B4%E6%9C%9F%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="期间掉落"><a href="#期间掉落" class="headerlink" title="期间掉落"></a>期间掉落</h2><ul><li>森林来信</li><li>树莓红茶</li><li>冰淇凌</li><li>池太黑西</li><li>明泉女子夏</li></ul><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>等待</p><h2 id="运输"><a href="#运输" class="headerlink" title="运输"></a>运输</h2><p>未知</p>]]></content>
      
      
      <categories>
          
          <category> JK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 45 </tag>
            
            <tag> M </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绯绯&amp;圣亚西六团</title>
      <link href="2020/01/30/%E7%BB%AF%E7%BB%AF&amp;%E5%9C%A3%E4%BA%9A%E8%A5%BF%E5%85%AD%E5%9B%A2/"/>
      <url>2020/01/30/%E7%BB%AF%E7%BB%AF&amp;%E5%9C%A3%E4%BA%9A%E8%A5%BF%E5%85%AD%E5%9B%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>等待</p><h2 id="运输"><a href="#运输" class="headerlink" title="运输"></a>运输</h2><p>未知</p>]]></content>
      
      
      <categories>
          
          <category> JK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 45 </tag>
            
            <tag> M </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小藤田高</title>
      <link href="2020/01/15/%E5%B0%8F%E8%97%A4%E7%94%B0%E9%AB%98/"/>
      <url>2020/01/15/%E5%B0%8F%E8%97%A4%E7%94%B0%E9%AB%98/</url>
      
        <content type="html"><![CDATA[<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>错过</p><h2 id="运输"><a href="#运输" class="headerlink" title="运输"></a>运输</h2><p>未知</p>]]></content>
      
      
      <categories>
          
          <category> JK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 45 </tag>
            
            <tag> M </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业礼</title>
      <link href="2020/01/09/%E6%AF%95%E4%B8%9A%E7%A4%BC/"/>
      <url>2020/01/09/%E6%AF%95%E4%B8%9A%E7%A4%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>已购</p><h2 id="运输"><a href="#运输" class="headerlink" title="运输"></a>运输</h2><p>送达</p>]]></content>
      
      
      <categories>
          
          <category> JK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 45 </tag>
            
            <tag> M </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="2019/11/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2019/11/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2>]]></content>
      
      
      <categories>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="2019/10/15/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>2019/10/15/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="2019/10/14/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>2019/10/14/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。这个排序其实和我们生活中打扑克牌是一样的，我们先整理好手上的牌，然后将后摸的牌插入手牌中合适的位置。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；<br>重复步骤2~5。</li></ul><h2 id="Java简单代码示例"><a href="#Java简单代码示例" class="headerlink" title="Java简单代码示例"></a>Java简单代码示例</h2><pre><code>   public static int[] insertionSort(int[] array) {    if (array.length == 0)//判断数组长度是否为零        return array;    int current;//临时变量    for (int i = 0; i &lt; array.length - 1; i++) {//遍历数组        current = array[i + 1];//变量存储数组中当前索引后一位值        int preIndex = i;//记录下标        /***         * 这里的while循环可以看作是从后向前的一个比较         */        while (preIndex &gt;= 0 &amp;&amp; current &lt; array[preIndex]) {//当下标大于等于零并且下一位小于当前位            array[preIndex + 1] = array[preIndex];            preIndex--;//这个索引--很多时候会忘了，造成下一步赋值错误，排序结果出现问题        }        array[preIndex + 1] = current;//循环中索引--了所以这里要加回来才是原来的索引    }    for (int j = 0; j &lt; array.length; j++)        System.out.print(array[j] + &quot;,&quot;);    return array;//返回排序好的数组}public static void main(String[] args) {    int[] arr = new int[]{2, 3, 2, 1, 8, 4, 5};    insertionSort(arr);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序—-工作</title>
      <link href="2019/10/13/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%B7%A5%E4%BD%9C/"/>
      <url>2019/10/13/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="小程序开发小结"><a href="#小程序开发小结" class="headerlink" title="小程序开发小结"></a>小程序开发小结</h2><p>微信小程序的开发是现在开发的一种潮流，很多公司都会为自己的产品打造一看小程序，方便用户使用，更好的推广自己。我在这里就不吐槽微信的开发文档有多烂，审核机制有多烂了。撇开细节上的用户体验，小程序开发也是有有点的，相较于普通的web开发，小程序的开发上手快，语法简单（基本沿用原生的JS和html语法）。缺点就是配合服务端需要已经部署的服务，调试起来存在应困难。因为审核的原因，无法在问题解决后及时上线。</p><h2 id="开发的坑"><a href="#开发的坑" class="headerlink" title="开发的坑"></a>开发的坑</h2><p>上面吐槽完了，下面记录一些我再小程序web开发过程中的问题。</p><ul><li><p>进入小程序的页面设定问题，小程序提交审核之前一定要仔细检查app.json这个文件，看仔细，是否设定好了小程序进入页面。</p></li><li><p>调试接口问题，小程序的调用接口必须是https请求的接口，所以开发之前要配置好接口。</p></li><li><p>微信密钥的问题，应该是所有做小程序服务开发都要注意的东西，密钥决定了服务与哪个小程序web连接，密钥只会在生成时可见，所以第一次生成一定要保存起来，忘了或者丢失后就要重新生成。</p></li></ul><p>持续更新开发小程序遇到的坑…………..</p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-工作</title>
      <link href="2019/10/12/MySQL-%E5%B7%A5%E4%BD%9C/"/>
      <url>2019/10/12/MySQL-%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-语法</title>
      <link href="2019/10/12/MySQL-%E8%AF%AD%E6%B3%95/"/>
      <url>2019/10/12/MySQL-%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL概念"><a href="#MySQL概念" class="headerlink" title="MySQL概念"></a>MySQL概念</h2><p>  MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。</p><h2 id="数据库的运用"><a href="#数据库的运用" class="headerlink" title="数据库的运用"></a>数据库的运用</h2><p>MySQL的使用大部分是语法的运用，深入的开发工程师还需要了解数据库的配置，学会通过数据库配置文件对数据进行调优。普通的后端开发工程师一般都不会区了解数据库的配置文件，更多的是运用SQL语句，满足开发过程中对数据的处理需求。在开发过程中可能有时会需要提升服务性能，大部分人都会选择通过优化SQL语句来提升（会出一篇详细的语句优化博客）。</p><h2 id="常见SQL语句"><a href="#常见SQL语句" class="headerlink" title="常见SQL语句"></a>常见SQL语句</h2><p>作为后端开发工程师，想要获取数据会时常和数据库打交道，这时候就需要使用SQL语句，对数据进行简单的处理，来获取存储的数据。下面整理一些开发中常用的SQL语句，总结一下可以概括为四个字（增删查改）</p><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>增：就是指新增数据添加进数据库存储,使用关键字insert。</p><pre><code>insert into table_name;</code></pre><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>删：就是指删除数据（删分为删除表内数据，删除表和删库），关键字有delete，truncate，drop。这三个关键字有各自不同的作用，delete是指删除数据，指定数据删除后，表还在其他数据不会受影响。truncate是清空表，表还存在，但是表内所有数据都清空，MySQL8.0之后执行truncate会同时释放表空间。dorp是彻底删除，执行drop之后数据，表，表空间都会被清除。</p><pre><code>delete from table_name where 条件truncate table table_namedrop table_name;</code></pre><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>查：查询数据是最常用的操作，查询数据也是语句优化的重点，查询数据需要各种条件才能查找到自己想要的数据，尽量精确数据。开发中的优化大部分都是优化查询操作，提升查询速度，使用的关键字select。</p><pre><code>select column_name from table_name where 条件;</code></pre><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p>改：数据库中的数据不是一成不变的，有很多时候需要进行更新修改，使用关键字update，alter。update是对数据进行修改，alter是对表结构进行修改。</p><pre><code>update table_name set field = new_field where 条件;alter table table_name add(drop) column_name;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-队列</title>
      <link href="2019/10/11/java-%E9%98%9F%E5%88%97/"/>
      <url>2019/10/11/java-%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><pre><code>队列是数据结构中比较重要的一种类型（是一种数据结构），它支持 FIFO，尾部添加、头部删除（先进队列的元素先出队列）</code></pre><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><pre><code>队列的特点就是先进先出，和生活中的排队等候差不多</code></pre><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><pre><code>队列有两种：单队列 ： 就是常见的队列，每次添加元素时，是添加对队尾。循环队列（暂时没看到）</code></pre><h2 id="Java简单代码实现"><a href="#Java简单代码实现" class="headerlink" title="Java简单代码实现"></a>Java简单代码实现</h2><pre><code>/*** desc : 队列的数组实现*/public class Queue {    private Object[] queue;    private int length;    private int head = 0;    private int tail = 0;    public Queue(int len) {        this.length = len;        queue = new Object[len];    }    public void enQueue(Object obj) {        if (tail == length) {            tail = 0;        }        queue[tail++] = obj;    }    public Object deQueue() {        if (queue[head] == null) {            return null;        }        Object temp = queue[head];        if (head == length) {            head = 0;        } else {            head++;        }        return temp;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-栈</title>
      <link href="2019/10/11/java-%E6%A0%88/"/>
      <url>2019/10/11/java-%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="栈的概念"><a href="#栈的概念" class="headerlink" title="栈的概念"></a>栈的概念</h2><pre><code>栈是一种只允许在一端进行插入或删除的线性表。栈的操作端通常被称为栈顶，另一端被称为栈底。栈的插入操作称作进栈（压栈|push）；栈删除操作称为出栈（弹栈|pop）</code></pre><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><pre><code>栈的特点是先进后出，就像超市货架上的货物，先放上去的压在下面，后放上去的在上面。</code></pre><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><pre><code>顺序存储的栈称作顺序栈（常用的是数组实现），链式存储的栈称作链式栈</code></pre><h2 id="Java简单代码实现"><a href="#Java简单代码实现" class="headerlink" title="Java简单代码实现"></a>Java简单代码实现</h2><p> 我们可以围绕栈的4个元素来实现栈：<br> 状态：是否栈空；是否栈满。<br> 操作：压栈push;进栈pop。</p><pre><code>/*** desc : 栈的数组实现*/public class Stack {    /**    * 栈的一些基础属性    */    private Object[] value;    private int top = -1;    private int size;    /**    * 构造方法    * @param size    */    public Stack(int size) {        value = new Object[size];        this.size = size;    }    /**    * 判断栈是否为空    * @return    */    public boolean isEmpty() {        return top == 0;    }    /**    * 栈添加元素    * @param val    */    public void push(Object val) {        if (top == size) {            throw new StackOverflowError();        }        value[++top] = val;    }    /**    * 栈取出元素    * @return    */    public Object pop() {        if (top &lt; 0) {            throw new EmptyStackException();        }        Object obj = value[top];        top--;        return obj;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="2019/10/11/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>2019/10/11/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h4 id="堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。"><a href="#堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。" class="headerlink" title="堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。"></a>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</h4><h4 id="堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。"><a href="#堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。" class="headerlink" title="堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。"></a>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</h4><h2 id="Java代码和详细注释如下："><a href="#Java代码和详细注释如下：" class="headerlink" title="Java代码和详细注释如下："></a>Java代码和详细注释如下：</h2><pre><code>public class HeapSort {    public static void main(String[] args) {        int[] arr = {7, 6, 7, 11, 5, 12, 3, 0, 1};        System.out.println(&quot;排序前：&quot; + Arrays.toString(arr));        sort(arr);        System.out.println(&quot;排序前：&quot; + Arrays.toString(arr));    }    public static void sort(int[] arr) {        //1.构建大顶堆        for (int i = arr.length / 2 - 1; i &gt;= 0; i--) {            //从第一个非叶子结点从下至上，从右至左调整结构            adjustHeap(arr, i, arr.length);        }        //2.调整堆结构+交换堆顶元素与末尾元素        for (int j = arr.length - 1; j &gt; 0; j--) {            swap(arr, 0, j);//将堆顶元素与末尾元素进行交换            adjustHeap(arr, 0, j);//重新对堆进行调整        }    }    /**    * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）    *    * @param arr    * @param i    * @param length    */    public static void adjustHeap(int[] arr, int i, int length) {        int temp = arr[i];//先取出当前元素i        for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) {//从i结点的左子结点开始，也就是2i+1处开始            if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) {//如果左子结点小于右子结点，k指向右子结点                k++;            }            if (arr[k] &gt; temp) {//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）                arr[i] = arr[k];                i = k;            } else {                break;            }        }        arr[i] = temp;//将temp值放到最终的位置   }    /**    * 交换元素    *    * @param arr    * @param a    * @param b    */    public static void swap(int[] arr, int a, int b) {        int temp = arr[a];        arr[a] = arr[b];        arr[b] = temp;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="2019/09/27/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>2019/09/27/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><pre><code>冒泡排序是所有排序算法中最基础的排序算法，冒泡排序十分稳定，但是当数据量庞大时，冒泡排序的耗时是最长的，冒泡排序的缺点就是需要消耗大量时间，优点是稳定。</code></pre><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><pre><code>比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</code></pre><h2 id="Java代码简单实现"><a href="#Java代码简单实现" class="headerlink" title="Java代码简单实现"></a>Java代码简单实现</h2><pre><code> public static void main(String[] args) {    //冒泡排序算法    int[] numbers=new int[]{1,5,8,2,3,9,4};    int i,j;    for(i=0;i&lt;numbers.length;i++)    {        for(j=0;j&lt;numbers.length-1-i;j++)        {            if(numbers[j]&lt;numbers[j+1])            {                int temp=numbers[j];                numbers[j]=numbers[j+1];                numbers[j+1]=temp;            }        }    }    System.out.println(&quot;排序后的结果是:&quot;);    for(i=0;i&lt;numbers.length;i++)        System.out.print(numbers[i]+&quot; &quot;);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础02</title>
      <link href="2019/09/23/java-%E5%9F%BA%E7%A1%8002/"/>
      <url>2019/09/23/java-%E5%9F%BA%E7%A1%8002/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础01</title>
      <link href="2019/09/18/java-%E5%9F%BA%E7%A1%8001/"/>
      <url>2019/09/18/java-%E5%9F%BA%E7%A1%8001/</url>
      
        <content type="html"><![CDATA[<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><ul><li>abstract ：表明类或者成员方法具有抽象属性</li><li>assert ：断言，用来进行程序调试</li><li>boolean ：基本数据类型之一，声明布尔类型的关键字</li><li>break ： 提前跳出一个块</li><li>byte ：基本数据类型之一，字节类型</li><li>case ：用在switch语句之中，表示其中的一个分支</li><li>catch ：用在异常处理中，用来捕捉异常</li><li>char ：基本数据类型之一，字符类型</li><li>class ：声明一个类</li><li>const ：保留关键字，没有具体含义</li><li>continue ：回到一个块的开始处</li><li>default ：默认，例如，用在switch语句中，表明一个默认的分支。Java8 中也作用于声明接口函数的默认实现</li><li>do ：用在do-while循环结构中</li><li>double ：基本数据类型之一，双精度浮点数类型</li><li>else ：用在条件语句中，表明当条件不成立时的分支</li><li>enum ：枚举</li><li>extends ：表明一个类型是另一个类型的子类型。对于类，可以是另一个类或者抽象类；对于接口，可以是另一个接口</li><li>final ：用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量</li><li>finally ：用于处理异常情况，用来声明一个基本肯定会被执行到的语句块</li><li>float ：基本数据类型之一，单精度浮点数类型</li><li>for ：一种循环结构的引导词</li><li>goto ：保留关键字，没有具体含义</li><li>if ：条件语句的引导词</li><li>implements ：表明一个类实现了给定的接口</li><li>import ：表明要访问指定的类或包</li><li>instanceof ：用来测试一个对象是否是指定类型的实例对象</li><li>int ：基本数据类型之一，整数类型</li><li>interface ：接口</li><li>long ：基本数据类型之一，长整数类型</li><li>native ：用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的</li><li>new ：用来创建新实例对象</li><li>package ：包</li><li>private ：一种访问控制方式：私用模式</li><li>protected ：一种访问控制方式：保护模式</li><li>public ：一种访问控制方式：共用模式</li><li>return ：从成员方法中返回数据</li><li>static ：表明具有静态属性</li><li>strictfp ：用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范</li><li>super ：表明当前对象的父类型的引用或者父类型的构造方法</li><li>switch ：分支语句结构的引导词</li><li>synchronized ：表明一段代码需要同步执行</li><li>this ：指向当前实例对象的引用</li><li>throw ：抛出一个异常</li><li>throws ：声明在当前定义的成员方法中所有需要抛出的异常</li><li>transient ：声明不用序列化的成员域</li><li>try ：尝试一个可能抛出异常的程序块</li><li>void ：声明当前成员方法没有返回值</li><li>volatile ：表明两个或者多个变量必须同步地发生变化</li><li>while ：用在循环结构中</li></ul><h3 id="private、default、protected、public的作用范围"><a href="#private、default、protected、public的作用范围" class="headerlink" title="private、default、protected、public的作用范围"></a>private、default、protected、public的作用范围</h3><pre><code>private:表示私有，只有自己的类能访问。----子类能继承，但是不能调用。default：表示没有修饰符修饰（即默认），只有同一个包的类能访问。protected：表示可以被同一个包的类以及其它包的子类访问。public：表示可以被该项目中的所有包的所有类访问。</code></pre><table><thead><tr><th>访问级别</th><th align="right">访问控制修饰符</th><th align="right">同类</th><th align="right">同包</th><th align="right">子类</th><th align="center">不同包(包括子类和非子类)</th></tr></thead><tbody><tr><td>公开</td><td align="right">public</td><td align="right">√</td><td align="right">√</td><td align="right">√</td><td align="center">√</td></tr><tr><td>受保护</td><td align="right">protected</td><td align="right">√</td><td align="right">√</td><td align="right">√</td><td align="center">×</td></tr><tr><td>默认</td><td align="right">没有修饰符</td><td align="right">√</td><td align="right">√</td><td align="right">×</td><td align="center">×</td></tr><tr><td>私有</td><td align="right">private</td><td align="right">√</td><td align="right">×</td><td align="right">×</td><td align="center">×</td></tr></tbody></table><h2 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h2><ul><li>byte: <pre><code>取值范围：-2^7~2^7-1所占空间：1个字节，8位</code></pre></li><li>short:<pre><code>取值范围：-2^15~2^15-1所占空间：2个字节，16位</code></pre></li><li>int:<pre><code>取值范围：-2^31~2^31-1所占空间：4个字节，32位</code></pre></li><li>long:<pre><code>取值范围：-2^63~2^63-1所占空间：8个字节，64位</code></pre></li><li>float:<pre><code>单精度32位所占空间：4个字节</code></pre></li><li>double:<pre><code>双精度64位所占空间：8个字节</code></pre></li><li>char: <pre><code>所占空间：2个字节</code></pre></li><li>boolean:<pre><code>所占空间：1/8个字节，1bit</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-权限</title>
      <link href="2019/09/18/linux-%E6%9D%83%E9%99%90/"/>
      <url>2019/09/18/linux-%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<p>常用的文件权限：</p><pre><code>444 r--r--r--600 rw-------644 rw-r--r--666 rw-rw-rw-700 rwx------744 rwxr--r--755 rwxr-xr-x777 rwxrwxrwx</code></pre><p>从左至右，1-3位数字代表文件所有者的权限，4-6位数字代表同组用户的权限，7-9数字代表其他用户的权限。<br>而具体的权限是由数字来表示的，读取的权限等于4，用r表示；写入的权限等于2，用w表示；执行的权限等于1，用x表示；<br>通过4、2、1的组合，得到以下几种权限：0（没有权限）；4（读取权限）；5（4+1 | 读取+执行）；6（4+2 | 读取+写入）；7（4+2+1 | 读取+写入+执行）<br>以755为例：</p><pre><code>1-3位7等于4+2+1，rwx，所有者具有读取、写入、执行权限；4-6位5等于4+1+0，r-x，同组用户具有读取、执行权限但没有写入权限；7-9位5，同上，也是r-x，其他用户具有读取、执行权限但没有写入权限。</code></pre><p>rwx权限数字解释 </p><pre><code>chmod也可以用数字来表示权限如 chmod 777 file语法为：chmod abc file其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。r=4，w=2，x=1若要rwx属性则4+2+1=7；若要rw-属性则4+2=6；若要r-x属性则4+1=7。</code></pre><p>范例：</p><pre><code>chmod a=rwx file 和 chmod 777 file 效果相同chmod ug=rwx,o=x file 和 chmod 771 file 效果相同若用chmod 4755 filename可使此程序具有root的权限</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 权限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-常用语法</title>
      <link href="2019/09/17/linux-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>2019/09/17/linux-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>规范: </p><ol><li>windows 的 jdk 安装位置不能有中文, 不能有空格. </li><li>建立的项目路径中不能有中文, 不能有空格.</li><li>虚拟机中均使用 root 权限.</li><li>虚拟机中安装路径统一</li><li>虚拟机密码简单[为了方便] </li><li>使用统一的版本.  </li></ol><p>注意：</p><pre><code>adduser 用户名passwd 用户名(给指定用户添加密码) cat /etc/passwd  查看所有用户</code></pre><p>使用sftp:</p><pre><code>注意你操作的是本地环境 还是远程linux环境命令不同   l--&gt;local上传put  从哪里上传到哪里下载get  从哪里下载到哪里以及操作的文件是什么（一般用rz从电脑本地拉取）</code></pre><p>安装虚拟机（克隆）</p><pre><code>在启动前先生成MAC地址注意网卡的设置删除70-persistent-net.rules目录，其中的mac地址也会被删除，重启后会自动重新生成rm -rf /etc/udev/rules..d/70-persistent-net.rules修改网卡设置vim /etc/sysconfig/network-scripts/ifcfg-eth0修改主机的名字vi /etc/sysconfig/network设置IP地址setup重启reboot</code></pre><p>网络映射修改hosts文件</p><pre><code>vim /etc/hosts192.168.200.134 node-1</code></pre><p>SSH安全外壳协议 </p><pre><code>Secure Shell，是一种网络安全协议，专门为远程登陆会话和其他网络服务提供安全的协议在node-1机器上ssh-keygen -t rsa 按四下回车生成密钥文件和私钥文件 id_rsa,id_rsa.pub将公钥拷贝给node-2机器ssh-copy-id node2首次登陆需要密码以后就是免密登陆</code></pre><p>grep</p><pre><code>ps -ef | grep sshd 查找指定 ssh 服务进程ps -ef | grep sshd | grep -v grep 查找指定服务进程，排除 gerp 本身ps -ef | grep sshd – c 查找指定进程个数cat a.txt | grep -f b.txt 从文件中读取关键词进行搜索输出 a.txt 文件中含有从 b.txt 文件中读取出的关键词的内容行cat a.txt | grep – nf b.txt 从文件中读取关键词进行搜索,显示行号grep -n &apos;linux&apos; test.txt 从文件中查找关键词，并显示行号cat test.txt |grep ^u 找出以 u 开头的行内容cat test.txt |grep ^[^u] 输出非 u 开头的行内容cat test.txt |grep hat$ 输出以 hat 结尾的行内容cat test.txt |grep -E &quot;ed|at&quot; 显示包含 ed 或者 at 字符的内容行</code></pre><p>find</p><pre><code>find . -name &quot;*.log&quot; -ls 在当前目录查找以.log 结尾的文件， 并显示详细信息find /root/ -perm 777 查找/root/目录下权限为 777 的文件find . -type f -name &quot;*.log&quot; 查找当目录，以.log 结尾的普通文件find . -type d | sort 查找当前所有目录并排序find . -size +100M 查找当前目录大于 100M 的文件</code></pre><p>locate</p><pre><code>locate 让使用者可以很快速的搜寻档案系统内是否有指定的档案。其方法是先建立一个包括系统内所有档案名称及路径的数据库。 之后当寻找时就只需查询这个数据库（/var/lib/locatedb）如果是精简版 CentOS 系统需要安装 locate 命令yum -y install mlocateupdatedb 命令来创建 locate 命令依赖的数据库updatedb</code></pre><p>使用实例：</p><pre><code>locate /etc/sh搜索 etc 目录下所有以 sh 开头的文件locate pwd查找和 pwd 相关的所有文件</code></pre><p>whereis</p><pre><code>whereis 命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。whereis 和下 locate 一样，会从数据库中查找数据，而不是像 find 命令那样，通过遍历硬盘来查找。</code></pre><p>使用实例：</p><pre><code>whereis ls 将和 ls 文件相关的文件都查找出来ls: /bin/ls /usr/share/man/man1/ls.1.gzwhereis -m ls 查找 ls 命令说明文档路径whereis -s ls 查找 ls 源文件</code></pre><p>which</p><pre><code>which 命令的作用是在 PATH 变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</code></pre><p>使用实例：</p><pre><code>which pwd 查找 pwd 命令所在路径/bin/pwdwhich java 查找 path 中 java 的路径/root/apps/jdk1.8.0_65/bin/javawhich 是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档， 所以，不同的 PATH 配置内容所找到的命令会不一样。</code></pre><p>su</p><pre><code>su用于用户之间的切换su在不加任何参数状态下，默认切换到root用户，但没有转到root用户根目录下；su加参数-，表示默认切换到root用户，并转到root用户根目录下。su不足：如果某个用户需要使用root权限，就必须把root密码告诉他退出返回之前的用户：exit</code></pre><p>sudo</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-基础语法</title>
      <link href="2019/09/06/linux-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>2019/09/06/linux-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Linux语句<br>.tar</p><pre><code>解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）</code></pre><p>.gz</p><pre><code>解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName</code></pre><p>.tar.gz 和 .tgz</p><pre><code>解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName</code></pre><p>mv file1 file2</p><pre><code>把当前目录下的file1文件名改成file2，如果该目录下有file2，则覆盖以前的file2文件。</code></pre><p>cp [options] sourcedir   destdir</p><pre><code>参数说明：    -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。    -d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。    -f：覆盖已经存在的目标文件而不给出提示。    -i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答&quot;y&quot;时目标文件将被覆盖。    -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。    -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。    -l：不复制文件，只是生成链接文件。    pwd       显示当前所在目录路径目录结构/    根目录root    系统管理员的家目录home    其他用户的家目录bin     存放二进制文件，可执行文件，常用命令etc    存放系统的配置文件lib     存放系统使用的函数类库tem    存放临时文件usr    存放应用程序 安装三方应用时存放的目录jdkvar    存放系统使用时经常发生变化的文件</code></pre><p>su 用户名    切换用户</p><pre><code>useradd 用户名    创建用户passwd  用户名    修改用户密码userdel -r 用户名    删除用户</code></pre><p>touch xx 创建文件<br>vi/vim编辑器</p><pre><code> vi 文件名        按字母i  进入到插入模式        在插入模式中修改文件内容 Esc     退出插入 按：    进入底行模式 wq      保存退出 q！     不保存退出查看文件内容 cat     路径/文件名称 more   路径/文件名称 可以向下翻页，查看文件内容 使用空格来实现向下翻页 less    路径/文件名称 可以向下翻页，也可以向上翻页，向上翻页pgup   向下翻页pgdn tail     10  路径/文件名称     -f  路径/文件名称    动态显示文件内容</code></pre><p>cd使用</p><pre><code>cd /      根目录cd ~      不管在什么文件打开home目录cd ..     返回当前目录的上级目录cd -      返回上一个目录</code></pre><p>ls     显示当前目录下的目录和子文件</p><pre><code>-a     显示所有文件和子目录-l     显示文件详情-h     带单位显示文件或文件夹大小</code></pre><p>ll       件详情 等价于 ls -l</p><pre><code>man      帮助文档clear  假清理屏幕reset  真清屏mkdir  目录名称   当前目录下创建目录       路径/目录名称  指定目录下创建目录 路径目录必须已经存在的       -p  路径/目录名称  创建路径目录创建目录</code></pre><p>rmdir  目录名称   删除名称目录，如果目录下存在子目录，不能删除<br>    路径/目录名称 删除路径下的名称目录</p><pre><code>rm     路径/目录名称 可以删除有内容文件的目录rm -f      强制删除文件，不能删除目录，没有提示rm -r      递归删除文件目录，有提示递归删除rm -f -r     直接删除目录，没有提示，混合使用</code></pre><p>复制文件</p><pre><code>cp       数据源    目的地/文件名mv    数据源    目的地/文件名（移动文件，重命名）    </code></pre><p>文本检索</p><pre><code> grep    检索规则 路径/名称 -A10（检索的前面10行） -B10（后面10行）管道 第一个命令 | 第二个命令    将第一个命令的结果使用第二种命令来输出</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
