<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java-队列</title>
    <link href="undefined2019/10/11/java-%E9%98%9F%E5%88%97/"/>
    <url>2019/10/11/java-%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><pre><code>队列是数据结构中比较重要的一种类型（是一种数据结构），它支持 FIFO，尾部添加、头部删除（先进队列的元素先出队列）</code></pre><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><pre><code>队列的特点就是先进先出，和生活中的排队等候差不多</code></pre><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><pre><code>队列有两种：单队列 ： 就是常见的队列，每次添加元素时，是添加对队尾。循环队列（暂时没看到）</code></pre><h2 id="Java简单代码实现"><a href="#Java简单代码实现" class="headerlink" title="Java简单代码实现"></a>Java简单代码实现</h2><pre><code>/*** desc : 队列的数组实现*/public class Queue {    private Object[] queue;    private int length;    private int head = 0;    private int tail = 0;    public Queue(int len) {        this.length = len;        queue = new Object[len];    }    public void enQueue(Object obj) {        if (tail == length) {            tail = 0;        }        queue[tail++] = obj;    }    public Object deQueue() {        if (queue[head] == null) {            return null;        }        Object temp = queue[head];        if (head == length) {            head = 0;        } else {            head++;        }        return temp;    }}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java-栈</title>
    <link href="undefined2019/10/11/java-%E6%A0%88/"/>
    <url>2019/10/11/java-%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="栈的概念"><a href="#栈的概念" class="headerlink" title="栈的概念"></a>栈的概念</h2><pre><code>栈是一种只允许在一端进行插入或删除的线性表。栈的操作端通常被称为栈顶，另一端被称为栈底。栈的插入操作称作进栈（压栈|push）；栈删除操作称为出栈（弹栈|pop）</code></pre><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><pre><code>栈的特点是先进后出，就像超市货架上的货物，先放上去的压在下面，后放上去的在上面。</code></pre><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><pre><code>顺序存储的栈称作顺序栈（常用的是数组实现），链式存储的栈称作链式栈</code></pre><h2 id="Java简单代码实现"><a href="#Java简单代码实现" class="headerlink" title="Java简单代码实现"></a>Java简单代码实现</h2><p> 我们可以围绕栈的4个元素来实现栈：<br> 状态：是否栈空；是否栈满。<br> 操作：压栈push;进栈pop。</p><pre><code>/*** desc : 栈的数组实现*/public class Stack {    /**    * 栈的一些基础属性    */    private Object[] value;    private int top = -1;    private int size;    /**    * 构造方法    * @param size    */    public Stack(int size) {        value = new Object[size];        this.size = size;    }    /**    * 判断栈是否为空    * @return    */    public boolean isEmpty() {        return top == 0;    }    /**    * 栈添加元素    * @param val    */    public void push(Object val) {        if (top == size) {            throw new StackOverflowError();        }        value[++top] = val;    }    /**    * 栈取出元素    * @return    */    public Object pop() {        if (top &lt; 0) {            throw new EmptyStackException();        }        Object obj = value[top];        top--;        return obj;    }}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆排序</title>
    <link href="undefined2019/10/11/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <url>2019/10/11/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="堆排序定义"><a href="#堆排序定义" class="headerlink" title="堆排序定义"></a>堆排序定义</h2><h3 id="堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。"><a href="#堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。" class="headerlink" title="堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。"></a>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</h3><h3 id="堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。"><a href="#堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。" class="headerlink" title="堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。"></a>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</h3><h2 id="Java代码和详细注释如下："><a href="#Java代码和详细注释如下：" class="headerlink" title="Java代码和详细注释如下："></a>Java代码和详细注释如下：</h2><pre><code>public class HeapSort {    public static void main(String[] args) {        int[] arr = {7, 6, 7, 11, 5, 12, 3, 0, 1};        System.out.println(&quot;排序前：&quot; + Arrays.toString(arr));        sort(arr);        System.out.println(&quot;排序前：&quot; + Arrays.toString(arr));    }    public static void sort(int[] arr) {        //1.构建大顶堆        for (int i = arr.length / 2 - 1; i &gt;= 0; i--) {            //从第一个非叶子结点从下至上，从右至左调整结构            adjustHeap(arr, i, arr.length);        }        //2.调整堆结构+交换堆顶元素与末尾元素        for (int j = arr.length - 1; j &gt; 0; j--) {            swap(arr, 0, j);//将堆顶元素与末尾元素进行交换            adjustHeap(arr, 0, j);//重新对堆进行调整        }    }    /**    * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）    *    * @param arr    * @param i    * @param length    */    public static void adjustHeap(int[] arr, int i, int length) {        int temp = arr[i];//先取出当前元素i        for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) {//从i结点的左子结点开始，也就是2i+1处开始            if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) {//如果左子结点小于右子结点，k指向右子结点                k++;            }            if (arr[k] &gt; temp) {//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）                arr[i] = arr[k];                i = k;            } else {                break;            }        }        arr[i] = temp;//将temp值放到最终的位置   }    /**    * 交换元素    *    * @param arr    * @param a    * @param b    */    public static void swap(int[] arr, int a, int b) {        int temp = arr[a];        arr[a] = arr[b];        arr[b] = temp;    }}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序</title>
    <link href="undefined2019/09/27/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>2019/09/27/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><pre><code>冒泡排序是所有排序算法中最基础的排序算法，冒泡排序十分稳定，但是当数据量庞大时，冒泡排序的耗时是最长的，冒泡排序的缺点就是需要消耗大量时间，优点是稳定。</code></pre><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><pre><code>比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</code></pre><h2 id="Java代码简单实现"><a href="#Java代码简单实现" class="headerlink" title="Java代码简单实现"></a>Java代码简单实现</h2><pre><code> public static void main(String[] args) {    //冒泡排序算法    int[] numbers=new int[]{1,5,8,2,3,9,4};    int i,j;    for(i=0;i&lt;numbers.length;i++)    {        for(j=0;j&lt;numbers.length-1-i;j++)        {            if(numbers[j]&lt;numbers[j+1])            {                int temp=numbers[j];                numbers[j]=numbers[j+1];                numbers[j+1]=temp;            }        }    }    System.out.println(&quot;排序后的结果是:&quot;);    for(i=0;i&lt;numbers.length;i++)        System.out.print(numbers[i]+&quot; &quot;);}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java-基础02</title>
    <link href="undefined2019/09/23/java-%E5%9F%BA%E7%A1%8002/"/>
    <url>2019/09/23/java-%E5%9F%BA%E7%A1%8002/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java-基础01</title>
    <link href="undefined2019/09/18/java-%E5%9F%BA%E7%A1%8001/"/>
    <url>2019/09/18/java-%E5%9F%BA%E7%A1%8001/</url>
    
    <content type="html"><![CDATA[<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><ul><li>abstract ：表明类或者成员方法具有抽象属性</li><li>assert ：断言，用来进行程序调试</li><li>boolean ：基本数据类型之一，声明布尔类型的关键字</li><li>break ： 提前跳出一个块</li><li>byte ：基本数据类型之一，字节类型</li><li>case ：用在switch语句之中，表示其中的一个分支</li><li>catch ：用在异常处理中，用来捕捉异常</li><li>char ：基本数据类型之一，字符类型</li><li>class ：声明一个类</li><li>const ：保留关键字，没有具体含义</li><li>continue ：回到一个块的开始处</li><li>default ：默认，例如，用在switch语句中，表明一个默认的分支。Java8 中也作用于声明接口函数的默认实现</li><li>do ：用在do-while循环结构中</li><li>double ：基本数据类型之一，双精度浮点数类型</li><li>else ：用在条件语句中，表明当条件不成立时的分支</li><li>enum ：枚举</li><li>extends ：表明一个类型是另一个类型的子类型。对于类，可以是另一个类或者抽象类；对于接口，可以是另一个接口</li><li>final ：用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量</li><li>finally ：用于处理异常情况，用来声明一个基本肯定会被执行到的语句块</li><li>float ：基本数据类型之一，单精度浮点数类型</li><li>for ：一种循环结构的引导词</li><li>goto ：保留关键字，没有具体含义</li><li>if ：条件语句的引导词</li><li>implements ：表明一个类实现了给定的接口</li><li>import ：表明要访问指定的类或包</li><li>instanceof ：用来测试一个对象是否是指定类型的实例对象</li><li>int ：基本数据类型之一，整数类型</li><li>interface ：接口</li><li>long ：基本数据类型之一，长整数类型</li><li>native ：用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的</li><li>new ：用来创建新实例对象</li><li>package ：包</li><li>private ：一种访问控制方式：私用模式</li><li>protected ：一种访问控制方式：保护模式</li><li>public ：一种访问控制方式：共用模式</li><li>return ：从成员方法中返回数据</li><li>static ：表明具有静态属性</li><li>strictfp ：用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范</li><li>super ：表明当前对象的父类型的引用或者父类型的构造方法</li><li>switch ：分支语句结构的引导词</li><li>synchronized ：表明一段代码需要同步执行</li><li>this ：指向当前实例对象的引用</li><li>throw ：抛出一个异常</li><li>throws ：声明在当前定义的成员方法中所有需要抛出的异常</li><li>transient ：声明不用序列化的成员域</li><li>try ：尝试一个可能抛出异常的程序块</li><li>void ：声明当前成员方法没有返回值</li><li>volatile ：表明两个或者多个变量必须同步地发生变化</li><li>while ：用在循环结构中</li></ul><h3 id="private、default、protected、public的作用范围"><a href="#private、default、protected、public的作用范围" class="headerlink" title="private、default、protected、public的作用范围"></a>private、default、protected、public的作用范围</h3><pre><code>private:表示私有，只有自己的类能访问。----子类能继承，但是不能调用。default：表示没有修饰符修饰（即默认），只有同一个包的类能访问。protected：表示可以被同一个包的类以及其它包的子类访问。public：表示可以被该项目中的所有包的所有类访问。</code></pre><table><thead><tr><th>访问级别</th><th align="right">访问控制修饰符</th><th align="right">同类</th><th align="right">同包</th><th align="right">子类</th><th align="center">不同包(包括子类和非子类)</th></tr></thead><tbody><tr><td>公开</td><td align="right">public</td><td align="right">√</td><td align="right">√</td><td align="right">√</td><td align="center">√</td></tr><tr><td>受保护</td><td align="right">protected</td><td align="right">√</td><td align="right">√</td><td align="right">√</td><td align="center">×</td></tr><tr><td>默认</td><td align="right">没有修饰符</td><td align="right">√</td><td align="right">√</td><td align="right">×</td><td align="center">×</td></tr><tr><td>私有</td><td align="right">private</td><td align="right">√</td><td align="right">×</td><td align="right">×</td><td align="center">×</td></tr></tbody></table><h2 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h2><ul><li>byte: <pre><code>取值范围：-2^7~2^7-1所占空间：1个字节，8位</code></pre></li><li>short:<pre><code>取值范围：-2^15~2^15-1所占空间：2个字节，16位</code></pre></li><li>int:<pre><code>取值范围：-2^31~2^31-1所占空间：4个字节，32位</code></pre></li><li>long:<pre><code>取值范围：-2^63~2^63-1所占空间：8个字节，64位</code></pre></li><li>float:<pre><code>单精度32位所占空间：4个字节</code></pre></li><li>double:<pre><code>双精度64位所占空间：8个字节</code></pre></li><li>char: <pre><code>所占空间：2个字节</code></pre></li><li>boolean:<pre><code>所占空间：1/8个字节，1bit</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux-权限</title>
    <link href="undefined2019/09/18/linux-%E6%9D%83%E9%99%90/"/>
    <url>2019/09/18/linux-%E6%9D%83%E9%99%90/</url>
    
    <content type="html"><![CDATA[<p>常用的文件权限：</p><pre><code>444 r--r--r--600 rw-------644 rw-r--r--666 rw-rw-rw-700 rwx------744 rwxr--r--755 rwxr-xr-x777 rwxrwxrwx</code></pre><p>从左至右，1-3位数字代表文件所有者的权限，4-6位数字代表同组用户的权限，7-9数字代表其他用户的权限。<br>而具体的权限是由数字来表示的，读取的权限等于4，用r表示；写入的权限等于2，用w表示；执行的权限等于1，用x表示；<br>通过4、2、1的组合，得到以下几种权限：0（没有权限）；4（读取权限）；5（4+1 | 读取+执行）；6（4+2 | 读取+写入）；7（4+2+1 | 读取+写入+执行）<br>以755为例：</p><pre><code>1-3位7等于4+2+1，rwx，所有者具有读取、写入、执行权限；4-6位5等于4+1+0，r-x，同组用户具有读取、执行权限但没有写入权限；7-9位5，同上，也是r-x，其他用户具有读取、执行权限但没有写入权限。</code></pre><p>rwx权限数字解释 </p><pre><code>chmod也可以用数字来表示权限如 chmod 777 file语法为：chmod abc file其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。r=4，w=2，x=1若要rwx属性则4+2+1=7；若要rw-属性则4+2=6；若要r-x属性则4+1=7。</code></pre><p>范例：</p><pre><code>chmod a=rwx file 和 chmod 777 file 效果相同chmod ug=rwx,o=x file 和 chmod 771 file 效果相同若用chmod 4755 filename可使此程序具有root的权限</code></pre>]]></content>
    
    
    <categories>
      
      <category>了解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux-常用语法</title>
    <link href="undefined2019/09/17/linux-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <url>2019/09/17/linux-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>规范: </p><ol><li>windows 的 jdk 安装位置不能有中文, 不能有空格. </li><li>建立的项目路径中不能有中文, 不能有空格.</li><li>虚拟机中均使用 root 权限.</li><li>虚拟机中安装路径统一</li><li>虚拟机密码简单[为了方便] </li><li>使用统一的版本.  </li></ol><p>注意：</p><pre><code>adduser 用户名passwd 用户名(给指定用户添加密码) cat /etc/passwd  查看所有用户</code></pre><p>使用sftp:</p><pre><code>注意你操作的是本地环境 还是远程linux环境命令不同   l--&gt;local上传put  从哪里上传到哪里下载get  从哪里下载到哪里以及操作的文件是什么（一般用rz从电脑本地拉取）</code></pre><p>安装虚拟机（克隆）</p><pre><code>在启动前先生成MAC地址注意网卡的设置删除70-persistent-net.rules目录，其中的mac地址也会被删除，重启后会自动重新生成rm -rf /etc/udev/rules..d/70-persistent-net.rules修改网卡设置vim /etc/sysconfig/network-scripts/ifcfg-eth0修改主机的名字vi /etc/sysconfig/network设置IP地址setup重启reboot</code></pre><p>网络映射修改hosts文件</p><pre><code>vim /etc/hosts192.168.200.134 node-1</code></pre><p>SSH安全外壳协议 </p><pre><code>Secure Shell，是一种网络安全协议，专门为远程登陆会话和其他网络服务提供安全的协议在node-1机器上ssh-keygen -t rsa 按四下回车生成密钥文件和私钥文件 id_rsa,id_rsa.pub将公钥拷贝给node-2机器ssh-copy-id node2首次登陆需要密码以后就是免密登陆</code></pre><p>grep</p><pre><code>ps -ef | grep sshd 查找指定 ssh 服务进程ps -ef | grep sshd | grep -v grep 查找指定服务进程，排除 gerp 本身ps -ef | grep sshd – c 查找指定进程个数cat a.txt | grep -f b.txt 从文件中读取关键词进行搜索输出 a.txt 文件中含有从 b.txt 文件中读取出的关键词的内容行cat a.txt | grep – nf b.txt 从文件中读取关键词进行搜索,显示行号grep -n &apos;linux&apos; test.txt 从文件中查找关键词，并显示行号cat test.txt |grep ^u 找出以 u 开头的行内容cat test.txt |grep ^[^u] 输出非 u 开头的行内容cat test.txt |grep hat$ 输出以 hat 结尾的行内容cat test.txt |grep -E &quot;ed|at&quot; 显示包含 ed 或者 at 字符的内容行</code></pre><p>find</p><pre><code>find . -name &quot;*.log&quot; -ls 在当前目录查找以.log 结尾的文件， 并显示详细信息find /root/ -perm 777 查找/root/目录下权限为 777 的文件find . -type f -name &quot;*.log&quot; 查找当目录，以.log 结尾的普通文件find . -type d | sort 查找当前所有目录并排序find . -size +100M 查找当前目录大于 100M 的文件</code></pre><p>locate</p><pre><code>locate 让使用者可以很快速的搜寻档案系统内是否有指定的档案。其方法是先建立一个包括系统内所有档案名称及路径的数据库。 之后当寻找时就只需查询这个数据库（/var/lib/locatedb）如果是精简版 CentOS 系统需要安装 locate 命令yum -y install mlocateupdatedb 命令来创建 locate 命令依赖的数据库updatedb</code></pre><p>使用实例：</p><pre><code>locate /etc/sh搜索 etc 目录下所有以 sh 开头的文件locate pwd查找和 pwd 相关的所有文件</code></pre><p>whereis</p><pre><code>whereis 命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。whereis 和下 locate 一样，会从数据库中查找数据，而不是像 find 命令那样，通过遍历硬盘来查找。</code></pre><p>使用实例：</p><pre><code>whereis ls 将和 ls 文件相关的文件都查找出来ls: /bin/ls /usr/share/man/man1/ls.1.gzwhereis -m ls 查找 ls 命令说明文档路径whereis -s ls 查找 ls 源文件</code></pre><p>which</p><pre><code>which 命令的作用是在 PATH 变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</code></pre><p>使用实例：</p><pre><code>which pwd 查找 pwd 命令所在路径/bin/pwdwhich java 查找 path 中 java 的路径/root/apps/jdk1.8.0_65/bin/javawhich 是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档， 所以，不同的 PATH 配置内容所找到的命令会不一样。</code></pre><p>su</p><pre><code>su用于用户之间的切换su在不加任何参数状态下，默认切换到root用户，但没有转到root用户根目录下；su加参数-，表示默认切换到root用户，并转到root用户根目录下。su不足：如果某个用户需要使用root权限，就必须把root密码告诉他退出返回之前的用户：exit</code></pre><p>sudo</p>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux-基础语法</title>
    <link href="undefined2019/09/06/linux-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>2019/09/06/linux-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Linux语句<br>.tar</p><pre><code>解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）</code></pre><p>.gz</p><pre><code>解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName</code></pre><p>.tar.gz 和 .tgz</p><pre><code>解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName</code></pre><p>mv file1 file2</p><pre><code>把当前目录下的file1文件名改成file2，如果该目录下有file2，则覆盖以前的file2文件。</code></pre><p>cp [options] sourcedir   destdir</p><pre><code>参数说明：    -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。    -d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。    -f：覆盖已经存在的目标文件而不给出提示。    -i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答&quot;y&quot;时目标文件将被覆盖。    -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。    -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。    -l：不复制文件，只是生成链接文件。    pwd       显示当前所在目录路径目录结构/    根目录root    系统管理员的家目录home    其他用户的家目录bin     存放二进制文件，可执行文件，常用命令etc    存放系统的配置文件lib     存放系统使用的函数类库tem    存放临时文件usr    存放应用程序 安装三方应用时存放的目录jdkvar    存放系统使用时经常发生变化的文件</code></pre><p>su 用户名    切换用户</p><pre><code>useradd 用户名    创建用户passwd  用户名    修改用户密码userdel -r 用户名    删除用户</code></pre><p>touch xx 创建文件<br>vi/vim编辑器</p><pre><code> vi 文件名        按字母i  进入到插入模式        在插入模式中修改文件内容 Esc     退出插入 按：    进入底行模式 wq      保存退出 q！     不保存退出查看文件内容 cat     路径/文件名称 more   路径/文件名称 可以向下翻页，查看文件内容 使用空格来实现向下翻页 less    路径/文件名称 可以向下翻页，也可以向上翻页，向上翻页pgup   向下翻页pgdn tail     10  路径/文件名称     -f  路径/文件名称    动态显示文件内容</code></pre><p>cd使用</p><pre><code>cd /      根目录cd ~      不管在什么文件打开home目录cd ..     返回当前目录的上级目录cd -      返回上一个目录</code></pre><p>ls     显示当前目录下的目录和子文件</p><pre><code>-a     显示所有文件和子目录-l     显示文件详情-h     带单位显示文件或文件夹大小</code></pre><p>ll       件详情 等价于 ls -l</p><pre><code>man      帮助文档clear  假清理屏幕reset  真清屏mkdir  目录名称   当前目录下创建目录       路径/目录名称  指定目录下创建目录 路径目录必须已经存在的       -p  路径/目录名称  创建路径目录创建目录</code></pre><p>rmdir  目录名称   删除名称目录，如果目录下存在子目录，不能删除<br>    路径/目录名称 删除路径下的名称目录</p><pre><code>rm     路径/目录名称 可以删除有内容文件的目录rm -f      强制删除文件，不能删除目录，没有提示rm -r      递归删除文件目录，有提示递归删除rm -f -r     直接删除目录，没有提示，混合使用</code></pre><p>复制文件</p><pre><code>cp       数据源    目的地/文件名mv    数据源    目的地/文件名（移动文件，重命名）    </code></pre><p>文本检索</p><pre><code> grep    检索规则 路径/名称 -A10（检索的前面10行） -B10（后面10行）管道 第一个命令 | 第二个命令    将第一个命令的结果使用第二种命令来输出</code></pre>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/09/03/hello-world/"/>
    <url>2019/09/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>